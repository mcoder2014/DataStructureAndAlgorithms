# Tcp

## TCP 报头

20 字节的固定首部，和一些可变首部。

```text
[                   2byte                  ][                   2byte                   ]

[                   源端口                  ][                   目的端口                  ]
[                   序号                    ][                    确认号                  ]
[数据偏移][保留][URC][ACK][PSH][PST][SYN][FIN][                    窗口                    ]
[                   校验和                  ][                  紧急指针                   ]
[                选项(长度可变)              ][                    填充                    ]
```

## TCP 连接建立与关闭

与 TCP 连接建立和销毁相关的几个重要字段

* seq:"sequance"序列号；
* ack:"acknowledge"确认号；
* SYN:"synchronize"请求同步标志；
* ACK:"acknowledge"确认标志"；
* FIN："Finally"结束标志。

### tcp 三次握手

#### 为什么要三次握手

在只有两次“握手”的情形下，假设Client想跟Server建立连接，但是却因为中途连接请求的数据报丢失了，故Client端不得不重新发送一遍；这个时候Server端仅收到一个连接请求，因此可以正常的建立连接。但是，有时候Client端重新发送请求不是因为数据报丢失了，而是有可能数据传输过程因为网络并发量很大在某结点被阻塞了，这种情形下Server端将先后收到2次请求，并持续等待两个Client请求向他发送数据...问题就在这里，Cient端实际上只有一次请求，而Server端却有2个响应，极端的情况可能由于Client端多次重新发送请求数据而导致Server端最后建立了N多个响应在等待，因而造成极大的资源浪费！所以，“三次握手”很有必要！

### TCP 的状态转换

* CLOSED 初始状态或者结束状态
* LISTEN 服务器调用 listen 函数
* SYN_SENT 客户端发送 SYN_SEND 来尝试建立连接
* SYN_RCVD 服务器收到 SYN 报文
* **ESTABLISHED** 连接建立
* FIN_WAIT_1 断开连接时，一方挥手，等待对方的回复 FIN 报文
* FIN_WAIT_2 半连接
* **TIME_WAIT** 收到了对方的 FIN 报文，回复了 ACK 消息，等待两个 MSL 时间 就会关闭。
* CLOSING
* CLOSE_WAIT 等待关闭
* LAST_ACK

### tcp 四次挥手

#### 为什么要四次挥手

试想一下，假如现在你是客户端你想断开跟Server的所有连接该怎么做？第一步，你自己先停止向Server端发送数据，并等待Server的回复。但事情还没有完，虽然你自身不往Server发送数据了，但是因为你们之前已经建立好平等的连接了，所以此时他也有主动权向你发送数据；故Server端还得终止主动向你发送数据，并等待你的确认。其实，说白了就是保证双方的一个合约的完整执行！

## TCP如何保证可靠性

1. 校验和
2. 序列号
3. 确认应答
4. 超时重传
5. 连接管理
6. 流量控制
7. 拥堵控制

## 超时重传 快重传

**超时重传**：当发送端发送数据，发生丢包时，则丢掉的包的ACK一直不会返回。此时发送端就一直等那个ACK返回，若超时，则重传该数据包。对于超时时间RTO，有很多复杂的算法。RTO的选择很重要，选短了，可能只是返回时间长但并未丢包，却当做丢包。选长了，迟迟不发丢的包也是个问题。

**快重传**：丢包了的处理方法不仅只有超时重传，还有快速重传。机制是：**丢包了，接收端重复发送丢包前的ACK，发送端每发送一个包过来，接收端就发相同的ACK回去**，这个ACK是对丢包之前的确认。当接收端连续收到3个相同的ACK，它就知道发生丢包了，根据ACK序号就能重发丢的包。

## 滑动窗口

滑动窗口有两个作用：**提供 TCP 的可靠性、提供 TCP 的流量控制**。接收端使用的流量控制。当接收端的应用程序从TCP缓存中提取数据速度过慢，导致TCP缓存中还有未被提取的数据，由于TCP缓存大小是固定的，则接收端下次能接收的数据量就变小了。

## 糊涂窗口

当滑动窗口变为0的时候，则发送端不能再继续发送任何数据。若之后应用程序从TCP缓存中提取了几个字节的数据，**则接收端会向发送端通告窗口更新了，你可以发数据过来了。但窗口只是更新了几个字节，而IP首部+TCP首部就有40字节，为了发这几个字节过来，会造成大量的带宽浪费。**所以，可以在发送端和接收端采取一定措施，避免糊涂窗口综合征。

## 流量控制算法 TCP拥塞控制

### 慢开始和拥塞避免

### 快重传和快恢复

## TCP的粘包问题有哪些解决方案

TCP是个“流”协议，所谓流，就是没有界限的一串数据。大家可以想想河里的流水，是连成一片的，其间并没有分界线。TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。

### 发生原因

1. 应用程序write写入的字节大小大于套接口发送缓冲区大小；
2. 进行MSS大小的TCP分段
3. 以太网帧的payload大于MTU进行IP分片

### 解决方案

由于底层的TCP无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，可以归纳如下：

1. 消息定长，例如每个报文的大小为固定长度200字节，如果不够，空位补空格；
2. 在包尾增加回车换行符进行分割，例如FTP协议；
3. 将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段，通常设计思路为消息头的第一个字段使用int32来表示消息的总长度；
4. 更复杂的应用层协议。

### 服务器可以创建多少个 TCP 连接

有一台服务器，他有一个IP，上面运行了一个TCP服务程序，程序侦听一个端口，问：理论上这个服务程序可以支持多少个并发 TCP 连接？

答案：在只考虑 IPv4 的情况下，并发数量的理论上限是 2^48，考虑到部分的 IP 地址作为了保留，可以适当的小一点儿，但数量级不变。实际的限制与操作系统的全局文件描述符数量、内存大小等有关。

一个 TCP 连接有两个 end points，每个 end point {ip, point}，因为其中服务器程序的 end point 已经确定，所以留下的只有一个 end point 的自由度。

## UDP

UDP用户数据报协议，是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。UDP通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象，实际应用中要求程序员编程验证。

UDP与TCP位于同一层，但它不管数据包的顺序、错误或重发。UDP主要用于那些面向查询---应答的服务，TFTP（简单文件传输协议）、SNMP（简单网络管理协议）、DNS（域名解析协议）、NFS、BOOTP

### UDP 报头

UDP的报头只有8字节长，包含源端口、目标端口、报文长度、及校验和。

```text
[   2byte  ][   2byte  ]

[  源端口号 ][ 目标端口号 ]
[ 数据报长度 ][   校验值  ]
```

### 区别与对比
