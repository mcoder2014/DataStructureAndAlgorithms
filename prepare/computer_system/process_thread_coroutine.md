# 进程 线程 协程

## 进程

进程（英语：process），是指计算机中已运行的程序。进程由程序段、相关数据段和PCB三部分组成：

1. 程序段是指进程运行的程序代码；
2. 数据段是指程序运行的相关数据；
3. PCB是进程控制块，包含进程的相关数据，是进程存在的唯一标志。

### 进程的状态转换

* 创建 new: 创建新的进程
* 运行 running: 进程正在运行
* 等待 waiting: 进程在阻塞，等待事件发生（如IO）
* 就绪 ready: 进程等待 CPU调度
* 结束 terminated: 进程运行完成

### PCB 进程控制块

process control block 是操作系统核心中的一种数据结构，一般包括如下内容：

* 状态: (创建、运行、等待、就绪、结束)
* PC 计数器: 指向要运行的指令地址
* CPU 寄存器: 保存寄存器的内容
* CPU 调度相关内容: 优先级、队列等参数
* 存储器管理: 页表等
* 统计信息: CPU 实际使用时间、账号、进程号等
* IO 信息: 进程使用的 IO 信息等

## 线程

线程是操作系统调度和分派的最小单位，同一个进程中的多个线程共享进程的全部系统资源：虚拟地址空间、文件描述符、信号处理等。但多个线程有各自的调用栈(call stack)，自己的寄存器环境(register context)，自己的线程本地存储(threadlocal)。

进程与线程的区别：进程是计算机管理运行程序的一种方式，一个进程下可包含一个或者多个线程。线程可以理解为子进程。

### 线程的状态

1. 运行状态
2. 就绪状态
3. 等待状态

### TCB 线程控制块

* 线程标识符
* 寄存器
* 线程运行状态
* 优先级
* 线程专有存储区
* 信号屏蔽

## 协程

协程非常类似于线程。但是协程是协作式多任务的，而线程典型是抢占式多任务的。这意味着协程提供并发性而非并行性。协程超过线程的好处是它们可以用于硬性实时的语境（在协程之间的切换不需要涉及任何系统调用或任何阻塞调用），这里不需要用来守卫关键区块的同步性原语（primitive）比如互斥锁、信号量等，并且不需要来自操作系统的支持。有可能以一种对调用代码透明的方式，使用抢占式调度的线程实现协程，但是会失去某些利益（特别是对硬性实时操作的适合性和相对廉价的相互之间切换）。

## 进程和线程的资源

进程拥有的：

* 全局变量；
* 堆上的数据；
* 静态变量；
* 代码区；
* 资源（如文件描述符）；

线程私有的：

* 局部变量(线程栈)；
* 函数参数(栈上或者寄存器上)
* 寄存器(包括 PC 程序计数器)
* ThreadLocal 变量

## 上下文切换

内核为每一个进程维持一个上下文。上下文就是内核重新启动一个被抢占的进程所需的状态。包括下列内容：

* 通用目的寄存器
* 浮点寄存器
* 程序计数器
* 用户栈
* 状态寄存器
* 内核栈
* 各种内核数据结构：比如描绘地址空间的页表，包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。

### 进程上下文切换和线程上下文切换的区别

线程之间共享虚拟内存空间，因此进程上下文切换涉及到了虚拟空间地址的切换（即 内存管理器中的”物理地址到虚拟地址“的内存页寄存器），而同一进程下的线程切换不涉及。

## 进程与线程的相关问题

### 1. 进程与线程的区别

1. **资源：** 进程拥有资源，进程是资源分配的基本单位，线程不具有资源，但线程可以访问所述进程的资源；
2. **调度：** 线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程的切换，从一个进程切换到另一个进程中的线程时，会引起进程切换；
3. **系统开销：** 创建、销毁进程的系统开销比创建和销毁线程的开销要大；进程切换时，系统开销也比线程切换时开销要大；
4. **通信方面：** 线程间通信可以直接通过访问进程中同一个数据块（通过互斥量、读写锁、条件变量、自旋锁、屏障等方式进行线程同步），进程要依赖于更多的进程间通信措施，复杂的得多（管道、FIFO、消息队列、信号量、共享存储等方式）

### 2. 协程是什么

**协程是一种用户态的轻量级线程**，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

### 3. 协程与多线程的比较

1. 一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU。
2. 线程进程都是同步机制，而协程则是异步
3. 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态
4. 协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程那样需要上下文切换来消耗资源，因此协程的开销远远小于线程的开销。

### 4. 协程的优点

### 5. 用进程还是用线程

多线程的优点很多，主要体现在性能上：

* 线程之间的数据共享很简单，因为共享了同一个内存空间，所以只要做好同步就可以共享数据，进程的数据同步更加麻烦；
* 创建线程快于创建进程；
* 线程的上下文切换快于进程的上下文切换；

多线程的缺点：

* 多线程的函数很多时候要确保线程安全，多进程则不需要关注这个；
* 某个线程的 bug 可能会影响整个进程，如 段错误会导致整个进程死掉；多进程隔离比较彻底，一个进程死了不会影响其他线程；
* 每个线程都争用宿主进程的有限的虚拟地址空间，可能会导致内存不够用；进程独享虚拟地址空间；

还有权衡点：

* 多线程应用中的信号处理要小心设计；
* 多线程中，所有线程必须运行同一个应用；
* 除了数据，线程还可以共享文件描述符等等很多资源；

## 进程调度算法

### 对批处理系统

1. **先来先服务（FCFS）** 非抢占式的调度算法，按照请求顺序进行调度。有利于长作业，不利于短作业。
2. **时间片轮转法** 每个进程有着相同的时间片，按照进程到达时间排序，时间片用完就将进程转换为等待状态放回队列中去。
3. **短作业优先（SJF）** 非抢占式调度算法，按照估计运行时间最短的顺序进行调度。导致长作业一直无法得到调度。
4. **最短剩余时间优先（SRTN）** 最短剩余时间是针对最短进程优先增加了抢占机制的版本。在这种情况下，进程调度总是选择预期剩余时间最短的进程。当一个进程加入到就绪队列时，他可能比当前运行的进程具有更短的剩余时间，因此只要新进程就绪，调度程序就能可能抢占当前正在运行的进程。像最短进程优先一样，调度程序正在执行选择函数是必须有关于处理时间的估计，并且存在长进程饥饿的危险。
5. **高响应比优先调度算法** 什么是高响应比，有响应之前应该会有请求，相当于是请求+响应+优先，算是一种综合的调度算法。也就是它结合了短作业优先，先来先服务以及长作业的一些特性。
   1. 短作业优先：短作业具有更高的优先级；
   2. 先来先服务：服务时间相同，先来的优先级更高；
6. **优先级调度算法**：优先级调度算法每次从后备作业队列中选择优先级最髙的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。在进程调度中，优先级调度算法每次从就绪队列中选择优先级最高的进程，将处理机分配给它，使之投入运行。

### 交互式系统

1. **时间片轮转法**
2. **优先级调度**
3. **多级反馈队列**

## Reference
