# 虚拟内存机制

## 虚拟内存机制，二级页表，TLB快表，缺页，swap

## 内存管理

区分物理内存和虚拟内存：

1. 物理内存：指实际的内存，CPU使用物理地址来访问主存中的数据；
2. 虚拟内存：每个进程都拥有自己的虚拟地址空间，地址是虚拟内存。实际访问主存时，有内存管理单元MMU将虚拟地址转换为物理地址。

**虚拟内存的目的**是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。也为了虚拟化机器，让程序不要绑定固定的内存地址空间。

为了应对内存碎片的问题，使用分页机制来管理内存。

- 分页
- 页表
- 多级页表

## 物理地址、逻辑地址、线性地址

- **物理地址**：它是地址转换的最终地址，是内存单元真正的地址。如果采用了分页机制，那么线性地址会通过页目录和页表得方式转换为物理地址。如果没有启用则线性地址即为物理地址

- **逻辑地址**：在编写c语言的时候，通过&操作符可以读取指针变量本省得值，这个值就是逻辑地址。实际上是当前进程得数据段得地址，和真实的物理地址没有关系。只有当在Intel实模式下，逻辑地址==物理地址。我们平时的应用程序都是通过和逻辑地址打交道，至于分页，分段机制对他们而言是透明得。逻辑地址也称作虚拟地址

- **线性地址**：线性地址是逻辑地址到物理地址的中间层。我们编写的代码会存在一个逻辑地址或者是段中得偏移地址，通过相应的计算(加上基地址)生成线性地址。此时如果采用了分页机制，那么吸纳行地址再经过变换即产生物理地址。在Intelk 80386中地址空间容量为4G，各个进程地址空间隔离，意味着每个进程独享4G线性空间。多个进程难免出现进程之间的切换，线性空间随之切换。基于分页机制，对于4GB的线性地址一部分会被映射到物理内存，一部分映射到磁盘作为交换文件，一部分没有映射，通过下面加深一下印象

## 虚拟内存到物理地址的映射过程

虚拟地址包含两部分，一部分是储存页面号，另一部分是储存偏移量。储存页面号可以在页表中寻找到该页，储存偏移量用来在该页中寻找到需要的内存。

1. 进程将虚拟地址传给CPU，CPU将地址传递给内存管理单元MMU；
2. MMU首先检查TLB，如果存在该虚拟地址映射，直接返回该映射；
3. 如果不存在，就访问页表，首先通过进程的页表基址和虚拟地址计算页表项的物理地址，然后就访问内存，取出页表项，并将其放置到TLB；
4. 得到映射/页表项后，如果对应的数据没有存储到内存，就引起一次**缺页中断**，将对应的内容放置到内存中。
5. 将物理地址传递给主存，主存返回对应数据。

## 缺页置换算法

1. **最佳**：选出最长时间内不再被访问的页面，通常可以保证获得最低的缺页率；
2. **最近最久未使用LRU**：将最近最久未使用的页面换出。需要在内存中维持一个链表，当一个页表被访问时将其移动到表头，保证每次链表最后一个元素是最近最久未使用的。
3. **最近未使用**：每个页面设置两个状态为 R 和 M ，当页面被使用时设置 R = 1，当页面被修改时设置 M=1 ，定期清零R，当发生缺页中断时，NRU算法优先从类编号最小的非空类中选择一个页面将它换出。NRU优先换出 R=0,M=1 的脏页面，而不是R=1,M=0的经常读写的干净数据。
4. **先进先出 FIFO**：最先进入的最先被换出

## 分段

虚拟内存采用的是分页技术，将地址空间映射为大小固定的页，每一页与内存进行映射。

### 分页与分段的区别

第一种方式，**页表**采用一个映射表代表虚拟地址到物理地址的映射，在计算机中我们叫做页表。页表将内存地址分为页号和偏移量，我们将高位部分称为内存地址的页号，后面的低位叫做内存地址的偏移量。我们只需要保存虚拟地址内存的页号和物理内存页号之间的映射关系即可。

- 虚拟地址-----> 页号+偏移量
- 通过页表查询出虚拟页号，对应的物理页号
- 物理页号+偏移量-----> 物理内存地址

第一种方式的页表占用空间，在一个32位的内存地址空间，页表需要记录2^20个物理页面的映射关系，可以想象为要给数组。那么一个页号是完整的4字节。这样一个页表就是4MB。每个进程都有各自的页表，因此内存占用会很大。

第二种方式，**多级页表**同样的虚拟内存地址，偏移量部分和上面方式一样，但是我们将页号部分拆分为四段，从高到低分成4级到1级的4个页表索引。

这样一来，每个进程将有4级页表。通过4级页表的索引找到对应的条目。通过这个条目找到3级页表所在位置，4级的每一个条目可能有多个3级的条目，找到了3级的条目后找到对应3级索引的条目，就这样到达1级页表。1级对应的则为物理页号。最终通过物理页号+偏移量的方式获取物理内存地址。

[17 分页与分段的区别](https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247493077&idx=3&sn=fe67d9761dfe24a3ae85522719324ece&chksm=fa0d8a54cd7a034256cb99892b60af5f16637ce20acb88085284c475d5bdc25465abdccb02f6&scene=126&sessionid=1598416845&key=91d5be5d38ee8c43738a7313ca818fd60dfa55e1bf5e9379eb14167e4cc989c38f4553f3a5a0661fbce5531fd3d915c9ea2ac5fa1d55d00f88a7525e5618a5ecb3d29a02263fe737a89cf78342969a3461fff45c61c45485d54b178d773d7e24ec75d4ec879ca9ba6e4b8837f28c0a9da051a6312ba693e05c865abe88d1542c&ascene=1&uin=MjM1Mzc3NDI2Mw%3D%3D&devicetype=Windows+10+x64&version=62090529&lang=zh_CN&exportkey=AaoZJW1gEwRagb6Uq4S%2Fnsw%3D&pass_ticket=6ms91QUYt9GyrVfOM6g3flhy7rmdrHh8Ez8%2ByTpwt94UCX79vJHVWp3O1mUkAK42)

## 多级页表的优缺点

优点：

- 使用多级页表可以让页表在内存中离散存储。多级页表通过索引就可以定位到具体的项。举个例子，假设当前虚拟地址空间为4G，每个页的大小为4k，如果是一级页表的话，共有2……20个页表项，假设每个页表项需要4B，那么存放所有的页表项需要4M，那么为了随机访问，我们就需要连续的4M内存空间存放所有的页表项。这样一来，随着虚拟地址空间的增大，需要存放页表所需的连续空间也就越来多大。如果使用多级页表，我们只需要一页存放目录项，页表存放在内存其他位置即可，下面有例子进一步讲解
- 使用多级页表更加节省页表内存。理论上，使用一级页表，需要连续存储空间存放所有项。使用多级页表只需要给实际使用的的那些虚拟地址内存的请求分配内存

**缺点**：使用一级页表的时候，只需要访问两次内存，一次是访问页表项，一次是访问需要读取的一页数据。如果是二级页表，就需要访问三次，第一次访问页目录，第二次访问页表项，第三次访问读取的数据。访问次数的增加以为访问数据所花费的总时间也增加

## 缓存算法

1. 先进先出（FIFO）：淘汰最早调入的页面。
2. 最近最久未使用（LRU）：选择最近最久未使用的页面予以淘汰。
3. 最近很少使用（LFU）：与LRU不同，LFU是基于访问次数的。
4. 时钟置换算法：时钟置换算法也叫最近未用算法 NRU（Not RecentlyUsed）。该算法为每个页面设置一位访问位，将内存中的所有页面都通过链接指针链成一个循环队列。
5. 最佳置换算法（OPT）：是一种理论上最佳的页面置换算法。它的思想是，试图淘汰掉以后永远也用不到的页面，如果没有则淘汰最久以后再用到的页面。因为这种算法必须知道进程访问页面的序列，而这是无法实现的，因此仅有理论意义。
