# 排列组合算法

# 全排列
字典序法是求全排列的经典方法，将元素按照字典的顺序进行排列，以字典的顺序作为比较的依据。

> 比如 "1" < "13"<"14"<"153"， 就是按每个数字位逐个比较的结果。对于一个串“123456789”， 可以知道最小的串是“123456789”，而最大的串“987654321”。这样针对这个串以字典序法生成全排列生成全排列，就是依次生成“123456789”->“123456798”->......->"987654312"->"987654321"这样的串。字典序法要求这一个与下一个有尽可能长的共同前缀，也即变化限制在尽可能短的后缀上。

## 算法步骤
给定集合`{1, 2, ..., n-1, n}`，设P是一个全排列：`p = {p[1], p[2], ..., p[j-1], p[j], p[j+1], ..., p[n]}`。

1. 从排列的右端开始，找出第一个比右边数字小的序号 `i`，即 `i = max{i | p[i] < p[i+1] }`;
2. 在 `p[j]` 的右边的数字中，找出所有比 `p[j]` 大的数字中的最小数字 `p[k]`，即 `k = min{i | p[i] > p[j], i>j}`;
3. 交换 `p[j], p[k]`;
4. 将排列右端的递减部分`p[j+1], p[j+2], ..., p[n]`倒转，因为j右端的数字是降序，所以两端交换，`O(n)`

```C++
vector<int> next_permutation(vector<int>& nums)
    {
        int n = nums.size(), i, j;
        for(i = n-2; i >=0; i--)
        {
            if(nums[i] < nums[i+1])
                break;
        }
        
        if(i < 0)
            // 已经完成全排列
            reverse(nums.begin(), nums.end());
        else
        {
            for(j = n-1; j > i; j--)
            {
                if(nums[j] > nums[i])
                    break;
            }
            swap(nums[i], nums[j]);
            reverse(nums.begin()+i+1, nums.end());
        }
        return nums;
    }
```

# 全组合

# Reference
