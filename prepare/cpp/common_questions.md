# 全局变量和static变量的区别.如果在两个.h文件中声明两个同名变量会怎么样？ 如果使用extern？ 如果没有使用

## static 关键词作用

1. 修饰类的静态变量；
2. 修饰函数的局部静态变量；
3. 修饰全局静态变量；
4. 修饰类的静态成员函数；
5. 修饰模块内函数，限定作用域范围仅在当前文件；

## extern 关键词

**extern是C/C++语言中表明函数和全局变量作用范围（可见性）的关键字** ，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用。

仅仅是一个变量的声明，其并不是在定义变量a，并未为a分配内存空间。变量a在所有模块中作为一种全局变量只能被定义一次，否则会出现连接错误。

通常，**在模块的头文件中对本模块提供给其它模块引用的函数和全局变量以关键字extern声明** 例如，如果模块B欲引用该模块A中定义的全局变量和函数时只需包含模块A的头文件即可。这样，模块B中调用模块A中的函数时，在编译阶段，模块B虽然找不到该函数，但是并不会报错；它会在连接阶段中从模块A编译生成的目标代码中找到此函数。

**与extern对应的关键字是static 被它修饰的全局变量和函数只能在本模块中使用** 因此，一个函数或变量只可能被本模块使用时，其不可能被extern “C”修饰。

--- 利用extern关键字先声明一下num变量，告诉编译器num这个变量是存在的，但是不是在这之前声明的，你到别的地方找找吧，果然，这样就可以顺利通过编译啦。如果extern这个关键字就这点功能，那么这个关键字就显得多余了，因为上边的程序可以通过将num变量在main函数的上边声明，使得在main函数中也可以使用。
extern这个关键字的真正的作用是引用不在同一个文件中的变量或者函数。

## .h 文件中的函数

**函数的声明和定义默认都是 extern 的, 即全局可见的. 所以在声明和定义的时候, 默认都是 extern的.** static修饰的 function 表明这个函数只对于当前文件中的其他函数是可见的, 其他文件中的函数不能够调用.

```C++
#include<stdio.h>

int func();

int main()
{
    func(); //1
    extern int num;
    printf("%d",num); //2
    return 0;
}

int num = 3;

int func()
{
    printf("%d\n",num);
}

extern "C"
{
    // 用来保持和C的兼容
}
```

## explicit 作用

用来阻止隐式类型转换发生；C++ 中只有一个参数的构造函数可能会进行隐式类型转换，在某些情况下可能会违背程序员的意愿。 explicit 阻止了这种隐式类型转换的发生。

## 如何避免C++函数传参时的拷贝

1. 传入指针；
2. 传入引用；
3. 智能指针 `std::shared_ptr<>`

## 避免C++函数返回值拷贝

1. 非局部对象可以使用return std::move(x)的方式去避免拷贝。
2. RVO C++ 函数返回值优化。

## volatile 作用

针对多线程程序，因为有寄存器和内存的存在，有可能当前类的值在寄存器中有缓存；万一内存中的值被其他线程修改了，却依旧在使用寄存器中的旧值会造成一些不一致问题。这个关键字要求每次用到该变量时都从内存中读。但 volatile 并不是线程安全的，线程安全的变量依旧需要加锁、或者使用原子变量。

## 参考链接

1. [C语言正确使用extern关键字](https://blog.csdn.net/xingjiarong/article/details/47656339)
