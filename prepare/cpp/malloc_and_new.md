# malloc和new的区别

## C++中有了malloc / free , 为什么还需要 new / delete

1. malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。
2. 对于非内部数据类型的对象而言，光用malloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以一个能完成清理与释放内存工作的运算符delete。
3. new能够自动计算需要分配的内存空间，而malloc需要手工计算字节数：

    ```cpp
    int * p1=new int[2];
    int * p2=(int*)malloc(sizeof(int) *2);
    ```

4. new的返回值不需要强制类型转换，因为new内置了sizeof()、类型转换和类型安全检查；而malloc返回void类型的指针，它本身并不识别内存是什么类型，它只关心内存的总字节数，因此需要强制类型转换。
5. new 是安全的，会进行类型检查

    ```cpp
    //int * p1= new float[2];编译时报错
    ```

6. new一般由两部分组成，分别是new操作和构造
7. malloc/free需要库函数<stdlib.h>支持
8. 内存释放：如果申请内存后不进行内存释放，就会出现内存泄露问题，所以new/delete、malloc/free必须配对使用。而且delete和free被调用后，内存不会立即收回，指针也不会指向空，而是仅仅告诉操作系统，这一块内存被释放了，可以用作其他用途。由于没有对这块内存进行写操作，所以内存中的变量数值并没有发生改变，出现野指针的情况，因此delete和free后，需要将指针指向置空。

## malloc 的原理

1. brk 是堆顶指针，堆向上增长。
2. 三个内存分配函数
   1. malloc(size_t size) 不初始化申请的内存空间
   2. calloc 将申请的空间初始化为 0
   3. realloc 申请调整已经分配的空间大小，需要重新分配内存空间
3. free(void *ptr) 释放申请的内存的空间

### 分配器

动态内存分配器维护着一个进程的虚拟内存区域，称为堆(heap)。C 使用动态内存分配器申请动态内存，维护着进程的虚拟内存空间。每个进程，内核维护着一个变量 brk，指向对顶元素。

分配器将堆视为一组不同大小的块组成的集合，每个块是一个连续的虚拟内存片，要么是已分配，要么是空闲的。已分配的块现实的保留为供应用程序使用。空闲的块可以用来分配。

#### 两种风格的内存分配器

- 显示分配器： 要求应用程序显式地释放任何已分配的块。例如 malloc free
- 隐式分配器： 分配器检测一个已经分配的块何时不再被程序使用，自主的释放这个块。如 Java 的垃圾回收器 GC。

#### 隐式空闲链表

分配器需要一些数据结构来区分块的边界，区分已分配块和未分配块。大多数分配器将这个信息嵌入到块本身：**头部 + 有效载荷 + [填充对齐]** 给块加上一个32位的头部，其中29位用来指示块大小，剩下三位作为标示位，表示一些信息。（因为如果要求块进行8位对齐，则块大小总为 8的倍数，则最后三位一直为0，可以拿出来存储信息。

头部后面是有效载荷，有效载荷后面是一片不使用的填充块，其大小可以是任意的。填充的目的可能是分配器的策略，也可能是系统对齐的要求。

这种结构便可以从堆顶指针一直根据块的头部信息，找到后续的块，因此称为隐形空闲链表。

##### 分配器策略

- 首次适配：从头搜索空闲链表，选择第一个合适的空闲块。
- 下一次适配：从上一次查询的地方开始，选择第一个合适的空闲块。
- 最佳适配：检查每个空闲块，找到适合所需请求大小的最小的空闲块。

##### 分割空闲块

对于一个新的匹配的空闲块，可以有两个决策，分配空闲块中的部分空间和分配整个空闲块。如果匹配的好，分配整个空间，可以减少碎片的产生。如果匹配的不太好，就将整个空闲块分为两块，一块用于分配，另一块变成新的空闲块。

##### 合并空闲块

当分配器释放一个块时，可能旁边有相邻的空闲块，会引起虽然空闲空间相邻，但是却有很多小的内存块的现象“假碎片”现象。

为了解决假碎片现象，分配器需要合并相邻的空闲块，这个过程叫做合并。可以立即合并，也可以推迟合并。

- 立即合并：立即合并指每次释放空间后就进行内存合并，缺点：如果频繁进行内存申请释放，可能导致频发合并、分割空闲块的抖动；
- 延迟合并：等到稍晚时再合并，比如分配失败后，分配器扫描整个堆，合并所有的空闲块。
