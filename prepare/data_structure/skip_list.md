# skip list

目前经常使用的平衡数据结构有：B树，红黑树，AVL树，Splay Tree, Treep等

跳表是一种随机化的数据结构，目前开源软件 Redis 和 LevelDB 都有用到它，它的效率和红黑树以及 AVL 树不相上下，但跳表的原理相当简单，只要你能熟练操作链表，就能轻松实现一个 SkipList。

跳表具有如下性质：

1. 由很多层结构组成
2. 每一层都是一个有序的链表
3. 最底层(Level 1)的链表包含所有元素
4. 如果一个元素出现在 Level i 的链表中，则它在 Level i 之下的链表也都会出现。
5. 每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。

## 跳表的操作

### 搜索

```c
/* 如果存在 x, 返回 x 所在的节点
 * 否则返回 x 的后继节点 */  
find(x)
{  
    p = top;  
    while (1) {  
        while (p->next->key < x)  
            p = p->next;  
        if (p->down == NULL)
            return p->next;  
        p = p->down;  
    }  
}  
```

### 插入

1. 先确定该元素要占据的层数k(用随机算法)
2. 然后再 Level1 ... Levelk 各个层的链表都插入元素
3. 如果k大于链表的层次，则需要添加新的层

### 删除

在各个层找到包含 x 的节点，使用标准方法删除元素

## 时间复杂度分析

跳表的索引高度 h = log2n，且每层索引最多遍历 3 个元素。所以跳表中查找一个元素的时间复杂度为 O(3*logn)，省略常数即：**O(logn)**，插入的时间复杂度同查找一样，为 **O(logn)**。

## 空间复杂度分析

跳表通过建立索引，来提高查找元素的效率，就是典型的“空间换时间”的思想，所以在空间上做了一些牺牲，那空间复杂度到底是多少呢？
假如原始链表包含 n 个元素，则一级索引元素个数为 n/2、二级索引元素个数为 n/4、三级索引元素个数为 n/8 以此类推。所以，索引节点的总和是：n/2 + n/4 + n/8 + … + 8 + 4 + 2 = n-2，空间复杂度是 O(n)。

## Redis 为啥使用跳表而不是红黑树来实现有序集合

Redis 中的有序集合(zset) 支持的操作：

1. 插入一个元素
2. 删除一个元素
3. 查找一个元素
4. 有序输出所有元素
5. 按照范围区间查找元素（比如查找值在 [100, 356] 之间的数据）

其中，前四个操作红黑树也可以完成，且时间复杂度跟跳表是一样的。但是，**按照区间来查找数据这个操作，红黑树的效率没有跳表高。按照区间查找数据时，跳表可以做到 O(logn) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了，非常高效。** 红黑树求前驱、后继节点的时间复杂度为 O(logn)

## Reference

1. [Redis 的设计与实现](#1)
2. [Skip List](https://www.iteye.com/blog/kenby-1187303)
3. [一文彻底搞懂跳表的各种时间复杂度、适用场景以及实现原理](https://juejin.im/post/5d90e4a15188252d3a6a60b8)
