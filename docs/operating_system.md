# 操作系统

## 编译
UNIX上编译一个c语言程序使用如下命令生成可执行文件`gcc -o hello hello.c`

编译系统分为预处理器(preprocessor)、编译器(compiler)、汇编器(assembler)和链接器(linker)四个部分组成。

1. 预处理阶段：预处理器（cpp）将根据以字符 '#' 开始的命令修改原始的C语言程序，得到另一个C语言程序，通常以`.i`作为文件后缀，例如`hello.i`；
2. 编译阶段：编译器（ccl）将文本文件`hello.i`翻译成文本文件`hello.s`，包含一个汇编语言程序。
3. 汇编阶段：汇编器（as）将`hello.s`翻译成机器语言指令，并把指令打包成一种可重定位目标程序（relocatable object program）的格式，并将结果保存在目标文件`hello.o` 中。
4. 链接阶段：链接器（ld）负责将一些已经存在于标准库中的目标文件合并到同一个文件中去(假设printf 函数存在于printf.o单独预编译好的目标文件中)，生成一个可执行目标文件`hello`。

## 了解编译系统如何工作带来的益处
1. 优化程序性能；
2. 理解链接时出现的错误；
3. 避免安全漏洞；

## 操作系统管理硬件
操作系统两个基本功能：
1. 防止硬件被失控的应用程序滥用；
2. 向应用程序提供简单一致的抽象机制来控制复杂而又通常不同的硬件外设；

操作系统通过提供（进程、虚拟存储器、文件）几个基本抽象概念来实现这两个功能。


# C 语言栈调用方式

IA32和x86-64的寄存器的名称及数量不一致，IA32有8个寄存器，x86-64有16个寄存器，IA32的寄存器`%ESP`用来做栈指针寄存器，指向栈顶，`%EBP`作为基准地址，指向栈帧开始；x86-64用`%rsp`做栈指针寄存器，指向栈顶，`%rbp`指向栈帧开始。栈的增长方向是向内存地址更小的方向增长，及新push的元素应该是`%rsp-8`此类的。

**X86-64** 的寄存器功能分类：
1. %rax 作为函数返回值使用。
2. %rsp 栈指针寄存器，指向栈顶
3. %rdi，%rsi，%rdx，%rcx，%r8，%r9 用作函数参数，依次对应第1参数，第2参数。。。
4. %rbx，%rbp，%r12，%r13，%14，%15 用作数据存储，遵循被调用者使用规则
5. %r10，%r11 用作数据存储，遵循调用者使用规则
6. 按照惯例`%rbx`、`%rbp`和`%r12-%r15`被划分为被调用者保存寄存器（Callee saved），即过程P调用了过程Q，则Q应该保证这些寄存器过程前后的值不会发生改变；其余的寄存器除了`%rsp`为调用者保存寄存器（Caller saved），即过程P在调用其他程序前应该保存这些寄存器的值在内存中，以免其他过程更改了寄存器的值导致出现bug。


从下面`IA32`和`x86-64`的寄存器对比上可以看到，x86-64的寄存器是在IA32的基础上扩充到64位，前缀从`e`换成了`r`，并且增加了8个寄存器`%r8-%r15`。

![IA32寄存器](imgs/IA32_c_registers.png)
IA32寄存器的名称及注释

![x86-64寄存器](imgs/x86_64_c_registers.png)
x86-64寄存器的名称及注释



## Reference
1. [你一定要搞明白的C函数调用方式与栈原理](https://mp.weixin.qq.com/s?__biz=MzU2MTkwMTE4Nw==&mid=2247486799&amp;idx=1&amp;sn=dcf7602b48a383d2d5cafcd6688d0445&source=41#wechat_redirect)
2. [CSAPP:3rd]()
